---
layout: post
title: 使用C#实现单例模式[译]
---

原文地址：[Implementing the Singleton Pattern in C#](http://csharpindepth.com/Articles/General/Singleton.aspx)

###目录
* 介绍
* 非线程安全版
* 使用简单的锁实现简单的线程安全
* Double-check锁
* 使用初始化实现安全
* 安全并且lazy静态初始化
* Lazy<T>
* 异常
* 优化
* 结论

###介绍
单例模式是软件工程中最为熟知的设计模式。本质上来说，单例是一种只允许创建一个实例的类，并且通常提供了简单的访问那个实例的方法。多数情况下，单例在创建实例的时候不允许使用任何参数，否则如果另外一个请求携带了一个不一样的参数将是一个很大的问题。（如果对实例的访问都使用同样的参数，工厂模式会更加合适。）本文只讨论没有参数的情况。同样来说，对单例模式的使用要求他们是延迟创建的——也就是说，对象直到首次使用时才创建。

在C#中有很多方式来实现单例模式。我现在将安排实现的优雅方式倒序来讲解，先开始讲最常用的实现，它也是非线程安全的，然后是延迟加载，线程安全，简单并且高效的版本。

但是所有的这些实现都有四个共性：

* 一个私有的并且无参数的构造函数。这就阻止了其他类进行初始化（是违反模式的的）。要注意，这同样阻止了子类——如果一个单例可以被子类化一次，它就可以被子类化两次，如果这些子类都可以创建一个实例，这就违反了模式。
* 类是封闭类。严格来说，基于上一点这是不必要的，但是这可以有助于JIT进行一些优化。
* 如果有实例，一个静态变量将会持有该实例的引用。
* 如果有需要的话，创建一个静态方法来获取创建的实例。

注意所有的实现都使用了一个静态的公共属性 `Instance` 来访问实例。在不影响线程安全或者优化的情况下，这个属性可以很容易地被转换为一个方法。

###第一个版本——非线程安全

        // 糟糕的代码，请不要使用！
        public sealed class Singleton
        {
            private static Singleton instance=null;

            private Singleton()
            {
            }

            public static Singleton Instance
            {
                get
                {
                    if (instance==null)
                    {
                        instance = new Singleton();
                    }
                    return instance;
                }
            }
        }

像标题上说的那样，这是线程不安全的。两个不同的线程在测试 `if (instance==null)` 的时候可能都认为是 `true`，他们将同时创建实例，这就违反了单例模式。注意在进行if判断的时候实例可能已经被创建了，但是内存模型没有保证新的实例的值能够被其他线程看见除非内存屏障已经传过来了。

###第二个版本——线程安全的

        public sealed class Singleton
        {
            private static Singleton instance = null;
            private static readonly object padlock = new object();

            Singleton()
            {
            }

            public static Singleton Instance
            {
                get
                {
                    lock (padlock)
                    {
                        if (instance == null)
                        {
                            instance = new Singleton();
                        }
                        return instance;
                    }
                }
            }
        }

这个实现是线程安全的。线程使用了锁来共享对象，在创建实例之前先检查了实例是否创建。考虑了内存屏障的问题（锁定确保在获得锁之后才能进行读操作，解锁确保在锁被释放后才能进行写操作）并且保证了只有一个线程可以创建一个实例（因为只有一个线程可以进入那段代码，当第二个线程进入的时候，第一个线程已经创建了实例，所以条件表达式将是`false`）。不幸的是，由于每次访问实例的时候都要请求锁，性能将会受到影响。

请注意，这种实现的有些版本采用锁定 `typeof(Singleton)` 的方式，但是我是给类的私有静态变量加了锁。如果把锁加在其他类可以访问的对象上并且锁定（比如 `type`）将可能导致性能问题甚至死锁。我有一个通常的编码风格，如果可能的话，只锁定在我为了锁定而特别创建的对象上，或者那些为了特殊目的（比如为了等待或脉冲队列）被锁定的文档上。通常这些对象在类中的私有的。这使得创建线程安全的应用很轻松。

