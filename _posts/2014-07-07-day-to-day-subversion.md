---
layout: post
title: Svn的日常使用[译]
tags:
- svn
- develop
---

回想一下你说过多少次：“我们正在开发的版本号是多少”或者“我们可以重新编译以修复一个 bug 并且发布一个更新吗”：

我觉得这样的场景更有意思：

>我们正在开发功能 Y 所以我们不能为功能 X 修复 Bug。那样做意味着我们把部分的功能 X 和功能 Y作为补丁一起发布出去。

这些都是源代码管理，补丁和保持工作流中间的一些典型问题。通常来说你很难同时继续当前的工作和对已经发布的产品追踪。有时候我们发布了未经测试或者未完全准备好的功能。例如，某个时候我发布了产品并且同时我不得不同时发送一个明显的说明给 QA 人 员并告诉他们：“不要按那个按钮！”。因为我们还没完成后台的功能或者功能还没有通过我们自己的测试。当然，他们按了并且记录了一个 bug 。同样的，我们自己也通常在测试一些问题的时候进入到另外功能的问题。

最近我们团队从 TFS 迁移到了 SVN（没有完全迁移，但是大部分已经迁移了）。在我们在进行分支的更新并且还没有合并好的时候想保持主干的稳定时，TFS 简直是一个可怕的噩梦，尤其是当你有多个分支的时候。

在进行切换的时候，我们得到了一个可以开发新特性的分支代码同时保持了主干的干净。在源代码管理圈子分支是一个很热的话题且已经因为引起圣战而被熟知。在我过去的生活中（一个月以前）我像躲避瘟疫一样躲避分支。这很可能是因为在 TFS 和 VSS 中使用分支（更重要的是合并回主干）简直就像是灌肠。你完全不想每天都做。

但是在一些项目中使用了这个过程(分支)并且经历了亲手进行日常合并后，它(分支)成为了我的朋友并使得构建一个长期功能特性能更容易驱动。

### 版本 1

通常在描述过程的时候代码和截图是最好的方式。这里的代码是非常简单的（仅仅只是一个包含一些自定义窗口和对话框的 WinForm 程序），但是不管项目多么大原理是一样的。

首先给我们的项目设置 svn 仓库。典型的设置是在项目中创建三个文件夹：branches，tags，和 trunk。branches 文件夹包含你正在开发新功能的分支；tags 文件夹代表项目中某个点（一般是发布）的备份；trunk 包含主要的代码并且一直都是稳定的。这些工作对组织你的代码和避免痛苦至关重要，随着我们的进行你将发现这一点。

下面是我们在 TortoiseSVN 中的示例仓库：

![image_40.png](/images/post/svn/image_40.png)

我们将从版本 1 开始，最基本的程序（众所周知的 WinForm 程序 “Hello World!”）。一个简单的只有一个窗口的程序。把这些签入到 svn 的 trunk 路径中。下面是更新后的仓库：

![image_thumb_18.png](/images/post/svn/image_thumb_18.png)

现在你的日复一日的编码开始了。Trunk 版本是最重要的（又名“王”），任何其他的工作将在分支中进行而他们是仆人。仆人很重要但是他们没有王重要。最重要和最高优先级的工作将在王上进行（并且这里只有一个王，拉斯维加斯宝贝万岁）。

让我们快进到我们开发的第 10 天。我们已经添加了一些窗口和代码（不同的人提交到的 trunk 中）并且是时候发布一个版本了。一次发布就是切断当前代码（或者其他任何你使用的方式，细节不重要）并且发布。在这个点，我们希望能标记这个发布。

### 标记和发布

标记通常用来识别一组代码，或者说是一个快照，用来让你稍后可以恢复。我们可以在以后想要重新构建系统的时候让所有文件回到那个修订版本的点。这通常是一次发布。举个例子，你把发布版本标记为 “1.0” 然后继续开发。在将来的某个时间你可以使用标记签出代码，重新构建，就像你在发布的那天一样。

我们将我们的发布标记为 “1.0”。这将在 "tags" 文件夹中创建整个代码的拷贝，但是实际上它们都是虚拟文件。跟其他源代码管理系统不一样的地方在于，这里没有真正创建一份拷贝，svn 的魔法让我们可以在之后签出这个标记相关的所有代码。

本质上来说，创建标记和分支看起来是一样的（都是同样的对话框），但是我们把标记放在不同的地方。svn 没有特殊的命令用于分支或者标记，而是使用了所谓的轻复制代替。请复制类似于 Unix 系统中的硬链接，意味着不是创建一个完全的仓库的复制，而是创建了一个内部的链接，指向了一个特定的树或者修订版本。这样的话分支和标记可以很快创建，而且几乎不耗费任何空间。

所以当对话框中说"复制"，其实你是在创建轻复制。不要因为你的项目非常大而生气，标记几乎没有做什么。下面是我们将添加的标记：

![image_thumb_2.png](/images/post/svn/image_thumb_2.png)

在创建标记的时候，你一般不会希望选中 “切换工作目录到新分支或标记” 。标记只是即时的快照，你将继续快乐地在主干进行下去。在分支上我们将做不一样的事情。所以当我们创建好了标记，在 TortoiseSVN 中看到这样的消息不要觉得奇怪：

![image_thumb_3.png](/images/post/svn/image_thumb_3.png)

下面是标记之后的代码库树。注意 tags 文件夹有了一个新的项。"1.0" 包含了一个 “trunk” 也就是我们的王的精确复制。

![image_thumb_4.png](/images/post/svn/image_thumb_4.png)

接下来就有意思了。我们标记了工作并且完成了发布。我们可以在以后的任何时候回到这个点并通过拉取 “1.0” 标记然后从这里构建或者发布这个版本。在这个点上我们产生了分支。我们想要工作在一个新的特性上。这将包含新的对话框和代码。

### 创建新的特性分支

我们为什么创建分支？分支是一个坏的东西吗？

不。分支，使用它来让你的主干干净。记住，我们只有一个王（trunk）。任何其他的工作都是仆人并且最终都会进入主干。

为什么我们要创建分支呢？想象一下如果我们没有分支。当你刚刚应用了 “1.0” 标签以后开始修改主干。当然，我们可以回到 “1.0” ，但是我们如果在只有一条线的情况下把更改合并？我们也违背了 “唯一的王” 规则。现在谁是王了？我们的新分支成为了一个仆人。王始终有优先级（例如修改 bug）但是工作可以在仆人分支上继续。

跟着我继续，最后你将会发现分支用来做什么而且为什么我们需要它。

我们就像创建一个标记那样创建一个分支。在这里我们把分支命名为 “1.1”，我们将会把我们的工作目录切换到分支。下面是分支对话框：

![image_thumb_5.png](/images/post/svn/image_thumb_5.png)

下面是创建完分支之后的代码库。现在我们的工作将提交到 “svn-demo/branches/1.1” 分支，保持主干的干净：

![image_thumb_6.png](/images/post/svn/image_thumb_6.png)

在 1.1 分支上我们正在添加新的特性。我们创建了新的窗口，修改了主窗口，并且一般还添加了新的方法。1.1 分支现在和主干有了很大的不同：

![image_thumb_7.png](/images/post/svn/image_thumb_7.png)

很多情况下都会出现这样的场景。举个例子，如果在我们发布的 1.0 版本中发现了一个 bug，你将怎么办？你不想污染 1.0 标记。这就是为什么 trunk 是王（并且这里只有一个王）。“trunk” 仍然是我们要在上面工作的最重要的事情（不管这个点是在测试还是生产还是其他任何东西）。除非已经验证了，其他任何的都是仆从。任何在主干上发现的问题都可以在主干上解决。所以下面让我们来体验这个场景。

### 等等，主干上有一个 bug !

1.0 版本有一个问题。窗口标题错误了。它显示的是 “Hello World!” 但是实际上应该是 "Hello World?"。

巨大的问题！停止催逼！停止主线任务。我们需要现在就修复这个问题。

你可能倾向于创建一个分支，然后修复它，然后合并回主干。这可能很常见，但是我们的主干是干净的所以我们可以直接在上面工作。把主干签出到本地文件，我们将在这里修改。然后签入回去。现在下面是修改后的代码库：

![image_thumb_8.png](/images/post/svn/image_thumb_8.png)

我已经高亮显示了修改的两个版本。"/tags/1.0" 现在是我们的发布后的版本（修订版25),"/trunk" 是我们的修复bug更新（修订版32）。在这个点上，我们仍然可以没有任何问题地发布 “1.0” 版本。

我们发布了我们的新主干（命名为　“1.0.1”）并且已经进行了一系列详尽的和密集的测试。我们巨大的更改经历了一周又一周的测试，最终 QA 接受了这个版本，并且允许发布到生产环境。这将在生产环境中使用 “1.0.1” 代替 “1.0” 并且更新标题栏。标记主干为 “1.0.1” 就像我们前面标记 “1.0” 那样，现在我们代码库看起来是这样的了：

![image_thumb_10.png](/images/post/svn/image_thumb_10.png)

### 图形是你的朋友

TortoiseSVN 有一个非常好的功能叫做 “修订图”，这可以给你一个你的分支和标记和修订的可视化的树状图。这个工具将伴你一声。下面是截止到目前我们的图：

![image_21.png](/images/post/svn/image_21.png)

在这个可视化树上我们可以知道：

+ 一个从主干修订版28创建的标记叫做 “1.0”,它的修订版是 29
+ 一个分支 "1.1" 是从主干的修订版 29 创建的
+ 工作继续在分支 “1.1” 上展开，每天都有提交（现在是修订版 31）
+ 一个标记 "1.0.1" 在主干的修订版32（修复 bug 后）上创建，创建了修订版 33

在这里我想指出这个方法的一些最大的好处

+ 你可以很容易的重新构建任何发布了的版本（当然，你得已经标记过）
+ 修正可以在主干上执行并且可以快速发布
+ 工作可以继续在特别的分支上进行而不需要打扰主要的工作

### 日常合并

所以现在我们有一点断线了不是吗？主干（修订版32）和重新发布的标记版本（1.0.1，修订版33）包含了我们需要的修补但是我们现在是工作在 1.1 分支上的特性X上的。我们没有这个修补。如果我们把代码合并回主干（我们在某些情况下不得不这样做）我们就将丢失这个修补，甚至可能让我们痛不欲生。

为了避免这个问题，任何在分支上工作的人都要遵循一项简单的规则。每天（意思是从开始的第一天起）都要从主干更新代码。换句话说，你需要把任何主干上被应用的更改应用到你的小分支上。这样做将让你在合并分支回主干的时候避免任何合并问题。

我们通过合并操作来完成这件事。这是一个简单的合并，但是合并也可能非常复杂和丑陋。在你的分支的工作目录中，你看不到主干上的更改。

下面是一个我们日常基本操作的合并对话框。我们将把主干的更改合并到 1.1 分支中：

![image_thumb_12.png](/images/post/svn/image_thumb_12.png)

关于合并的一些注意事项：

+ 我们从主干合并并且在最上面声明分支。这看起来似乎是倒退，但是当两个树（主干和分支）同步的时候，这是需要合并到最近修订版的时间点。记住，我们是在查找自从我们创建分支以来“从主干到分支”的所有更改。在确定这个的时候修订版图是至关重要的。在这个例子中，这是我们创建完分支（修订版30）后第一次进行同步。
+ 默认的合并使用“From”值，但是我们想合并进分支中，所以不要选择这个并且在“To”这里选择主干。对主干，我们将选择 "HEAD" 修订版但是这里刚好就是 32 。选择 "HEAD" 或 修订版32 这里将得到同样的合并结果。
+ 在下面部分确定你想要的位置和操作。工作目录应该是你当前的工作目录，并且应该结束于你当前的分支。
+ 通常（请经常）首先进行 "Dry run" 并且确定你将要做的更新是正确的。

在这个合并中我们想要获得对 MainForm.Designer.cs 的更改（修复 bug）。如果我们在分支上选择了 “HEAD” 而不是我们我们从主干分离的时候的修订版，我们可以对比所有的更改。在 dry run 中的结果将告诉我们我们有了新的窗口。这是不正确的，因为 a) 我们只想要从主干得到更改 b) 主干不知道（或者说不需要知道）任何我们创建的新窗口。我们目前只对主干上面发生的更改感兴趣。

下面是正确的 dry run 窗口结果（基于上一次合并窗口）：

![image_thumb_13.png](/images/post/svn/image_thumb_13.png)

完美！我们希望得到 MainForm.Designer.cs 的更改（或者任何自从上一次同步以来的更改）而且我们已经得到了。执行并且把主干的更改应用到你的分支。

当你执行合并，你已经把更改合并到了你的工作目录，但是这里还有一步需要做。这将修改你的工作的代码但是现在你需要提交到代码库中。如果你检查你的更新你将看到你的 MainForm.Designer.cs 文件已经更改了。下面是更改的差异：

    Index: D:/Development/spikes/SvnMergeDemo/WindowsApplication1/MainForm.Designer.cs 
    =================================================================== 
    --- D:/Development/spikes/SvnMergeDemo/WindowsApplication1/MainForm.Designer.cs    (revision 31) 
    +++ D:/Development/spikes/SvnMergeDemo/WindowsApplication1/MainForm.Designer.cs    (working copy) 
    @@ -61,7 +61,7 @@ 
                 this.Controls.Add(this.button1); 
                 this.Name = "MainForm"; 
                 this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen; 
    -            this.Text = "Hello World!"; 
    +            this.Text = "Hello World?"; 
                 this.Load += new System.EventHandler(this.MainForm_Load); 
                 this.ResumeLayout(false);

你可以看到，标题栏这里已经更改了替换了我们的原来的版本（有bug的）。

把这个提交到代码库。你的分支已经拥有了主干的更改并且你可以继续在新的特性上工作了。

记住，在分支上工作的要点就是不要使用我们的新对话框或者代码污染主干，还要每天做合并（相信我，不管什么代码库，这最多花费你5分钟）保证你的分支和主干上发生的更改同步。

### 回到主干

我们一天又一天地在 1.1 分支上工作，并且越来越多的更改在主干上发生了。更多的 bug 修复等等。但是我们没有引入新的特性。我们只是在分支上添加新特性。在罕见的实例中我们正在进行一个功能开发的时候另外一个也在进行中，我们可能有另外一个团队创建了另外一个分支。我将保持最小的激活的分支。这让生活变得困难。

不管怎样，我们继续我们的分支开发直到我们准备好了发布。此时我们应该拥有一个稳定的主干（我们应该一直都有一个稳定的主干）并且还有一系列的标记。所以主干上的更改都已经应用到了分支并且我们团队决定是时候发布一个新版本替代 1.0.1 了。这是我们的分支 1.1 并且我们想要把所有的 1.1 中的新东西合并回主干。

下面是我们的代码库：

![image_thumb_14.png](/images/post/svn/image_thumb_14.png)

+ 1.1 分支包含了我们所有的新工作，3个新加的窗口和对主窗口的一些修改以调用新窗口
+ 因为我们进行了每日“从主干合并”的例行工作,我们拥有主干上面进行的任何 bug 修复或者更改。
+ 我们的主干是干净的并且我们发布了多个版本（使用多个标记放入到了 tags 文件夹下）

为了合并回主干，我们需要进行和每日例行合并的相反的操作。不再是合并到主干，而是反过来合并回主干。同样的，你需要一个主干的工作目录用来合并回去。把主干签出道一个文件夹中并且进行合并。再一次，这里的重点是选择正确的修订版本号。对分支来说，是 "HEAD" 版本。对主干，是上一次同步时候的点，这里是修订版 32。下面是提交 1.1 功能到主干的合并对话框。

![image_thumb_15.png](/images/post/svn/image_thumb_15.png)

在这里，我们正在提交更改到一个主干的工作目录（我们签出主干的位置）。点击 “Diff” 查看我们将应用的更改：

![image_37.png](/images/post/svn/image_37.png)

在这里，我们已经添加了多个窗口并且对 MainForm.cs 和 MainForm.Designer.cs 做了修改（我们添加了一些按钮来调用新的对话框）。下面是对 MainForm.Designer.cs 文件的统一差异描述（为了简洁省略了一些行）：

    Index: MainForm.Designer.cs 
    =================================================================== 
    --- MainForm.Designer.cs    (.../trunk)    (revision 35) 
    +++ MainForm.Designer.cs    (.../branches/1.1)    (revision 35) 
    @@ -28,13 +28,49 @@ 
             /// </summary> 
             private void InitializeComponent() 
             { 
    +            this.button1 = new System.Windows.Forms.Button(); 
    +            this.button2 = new System.Windows.Forms.Button(); 
    +            this.button3 = new System.Windows.Forms.Button(); 
                 this.SuspendLayout(); 
                 // 
    +            // button1 
    +            // 
    +            this.button1.Location = new System.Drawing.Point(12, 12); 
    +            this.button1.Text = "Search"; 
    +            // 
    +            // button2 
    +            // 
    +            this.button2.Location = new System.Drawing.Point(12, 41); 
    +            this.button2.Text = "Admin"; 
    +            // 
    +            // button3 
    +            // 
    +            this.button3.Location = new System.Drawing.Point(12, 70); 
    +            this.button3.Text = "Customers"; 
    +            // 
                 // MainForm 
                 // 
    +            this.Controls.Add(this.button3); 
    +            this.Controls.Add(this.button2); 
    +            this.Controls.Add(this.button1); 
                 this.Name = "MainForm"; 
                 this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen; 
                 this.Text = "Hello World?"; 
    @@ -44,6 +80,10 @@ 
             } 
             #endregion 
    + 
    +        private System.Windows.Forms.Button button1; 
    +        private System.Windows.Forms.Button button2; 
    +        private System.Windows.Forms.Button button3; 
         } 
    }

注意这个差异文件的底部，`this.Text="Hello World?"`。这是我们日常合并的结果，所以这里没有更改需要合并回主干。这里已经同步了。只有把主干提升到 1.1 分支工作的 修改/添加/删除 才会被应用。再一次，进行 dry run。你应该看到只有分支中做的新工作会被应用到主干。如果不是，停下来，放弃合并，检查你的修订版本号。

再一次，主干现在和 1.1 分支合并为一致了。此时你应该载入解决方案，构建，运行单元测试等。并且理智的检查所有事情都像期望的那样。然后你就可以发布新的版本并且标记主干为 1.1 了。

你可以遗弃分支文件夹或者仍然放到代码库中。毕竟，它只是一个链接，而不会占用太多的空间。（我们在 CruiseControl.NET 上每次构建都标记了代码库，现在已经有数百个标记了,没什么大不了的）

### 泡沫，漂洗，重复

现在回到你的主干。主干就是王，这是唯一的王，你日复一日的继续工作在你的功能上。你应该有“永远生活在分支上” 的观点，这是个主意但是需要你每天都从主干合并代码而且这可能导致问题。“在主干运行” 和 从主干构建都没有问题。重点是当你发布而且想要继续一个不同的工作时你应该建立分支，否则整个团队每天都合并回主干是可以的。

当有了一个新的特性，分支，把部分团队（或者整个团队）移动到这个分支并保持主干的干净，如果发现bug就修复bug。在适当的时候把新特性合并回主干。如果有需要就一直这样做，直到你用光了所有的钱或者团队退出了。坐下来，放松，享受简单的生活。

### 结论

这似乎看起来有点复杂但是当你熬下来之后你会发现是非常基本的。只需要遵循一些基本的规则：

+ 作为一个日常工作，在分支上工作的开发者把主干的更改合并到自己的分支中
+ 当你准备好发布的时候把功能分支合并回主干
+ 在主干上进行 bug 修复然后标记下来并且重新发布

如果你卡住了或者失败了可以给我发邮件，或者让我知道你经历了什么。

享受这一切吧！

<http://weblogs.asp.net/bsimser/day-to-day-with-subversion>
